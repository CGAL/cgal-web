---
layout: post
title: "CGAL 3.0"
description: "CGAL 3.0 released"
category:
tags: ["release"]
---
{% include JB/setup %}
<p>Version 3.0 differs from version 2.4 in the platforms that are supported and
in functionality.  There have also been a number of bug fixes for this release.</p>

<p>The license has been changed to either the LGPL (GNU Lesser General Public
License v2.1) or the QPL (Q Public License v1.0) depending on each package.
So CGAL remains free of use for you, if your usage meets the criteria of these
licenses, otherwise, a commercial license has to be purchased from
GeometryFactory.</p>

<p>
Additional supported platforms:
<UL>
   <LI> MS Visual C++, version 7.1. </li>
   <LI> SunPro CC versions 5.4 and 5.5 on Solaris </li>
   <LI> GNU g++ versions 3.2 and 3.3 on Linux, Solaris, Irix, cygwin, and FreeBSD. </li>
   <LI> MipsPRO CC 7.30 and 7.40 with both the n32 and n64 ABIs. </li>
</UL>
<p>
The following platforms are no longer supported:
<UL>
   <LI>MS Visual C++, version 6. </li>
   <LI>  GNU g++ 2.95.2 (2.95.3 is still supported) </li>
   <LI>  Kai C++ and Borland C++, all versions </li>
</UL>

<p>
The following functionality has been added or changed:<BR><BR>

<B>All</B>
<UL>
    <LI> The  CORE library for exact
      computations is now distributed as part of CGAL as well. </li>
</UL>


<H3>Kernels</H3>


<UL>
   <LI>3 typedefs have been added to ease the choice of a robust and fast kernel:
     <UL>
      <LI> Exact_predicates_inexact_constructions_kernel </li>
      <LI> Exact_predicates_exact_constructions_kernel </li>
      <LI> Exact_predicates_exact_constructions_kernel_with_sqrt </li>
     </UL> </li>
    <LI> Progress has been made towards the complete adaptability and
      extensibility of our kernels. </li>
    <LI> New faster Triangle_3 intersection test routines.
		<br><i>(see Erratum)</i> </li>
    <LI> Added a Kernel concept archetype to check that generic algorithms
      don't use more functionality than they should. </li>
    <LI> A few more miscellaneous functions. </li>
</UL>

<H3>Basic Library</H3>

<UL>
  <LI> 2D Apollonius Graph (new package)<BR>
Algorithms for computing the Apollonius
      graph in two dimensions.  The Apollonius graph is the dual of the
      Apollonius diagram, also known as the additively weighted Voronoi
      diagram.  The latter can be thought of as the Voronoi diagram of a set
      of circles under the Euclidean metric, and it is a generalization of the
      standard Voronoi diagram for points.  The algorithms provided are
      dynamic.
 </li>
 
  <LI>dD Min Sphere of Spheres (new package)<BR>
      Algorithms to compute the smallest
      enclosing sphere of a given set of spheres in R<sup>d</sup>.
      The package provides
      an algorithm with maximal expected running time
      <i>O(2<sup>O(d)</sup> n)</i> and a
      fast and robust heuristic (for dimension less than 30).
 </li>
 
<LI>Spatial Searching (new package)<BR>
Provides exact and approximate distance
      browsing in a set of points in <i>d</i>-dimensional space using
      implementations of algorithms supporting:
      <ul>
        <li> both nearest and furthest neighbor searching </li>
        <li> both exact and approximate searching </li>
        <li> (approximate) range searching </li>
        <li> (approximate) <i>k</i>-nearest and <i>k</i>-furthest neighbor
             searching </li>
        <li> (approximate) incremental nearest and incremental furthest neighbor
          searching </li>
        <li> query items representing points and spatial objects. </li>
      </ul>
 </li>
 
 <LI><B>Kd-tree</b><br>
this package is deprecated, its documentation is removed.
      It is replaced by the Spatial Searching package.
 </li>


  <LI>Largest_empty_rectangle_2<BR>
       Given a set of points P in the plane, the class
       Largest_empty_iso_rectangle_2 is a data structure that
       maintains an iso-rectangle with the largest area among all
       iso-rectangles that are inside a given iso-rectangle bounding box,
       and that do not contain any point of the point set P.
  </li>

<LI> 2D Triangulation and
     3D Triangulation<BR>
     <UL>
      <LI> The classes Triangulation_data_structure_2 (and 3), which implements
        the data structure for 2D triangulation class, now makes use of
        CGAL::Compact_container (see Support Library section below). </li>
      <LI> The triangulation classes use a Rebind mecanism to provide
        the full flexibility on Vertex and Face base classes.
        This means that it is possible for the user to derive its own Face
        of Vertex base class, adding a functionality that makes use of
        types defined by the triangulation data structure like Face_handle
        or Vertex_handle. </li>
      <LI> New classes Triangulation_vertex_base_with_info_2 (and 3) and
	Triangulation_face_base_with_info_2 (and 3) to make easier the
        customisation of base classes in most cases. </li>
     </UL>
 </li>


<LI> 2D Triangulation<BR>
     <UL>
      <LI> Regular triangulation provides an easy access to hidden points. </li>
      <LI> The Triangulation_hierarchy_2, which provide an efficient location
	data structure, can now be used with any 2D triangulation class plugged
        in (including Regular triangulations). </li>
      </ul>
 </li>


<LI> 3D Triangulation<BR>
     <UL>
     <LI> faster vertex removal function in Delaunay_triangulation_3. </li>
      <LI> Delaunay_triangulation_3 is now independent of the order of insertions
        of the points (in case of degenerate cosphericity). </li>
      <LI>Regular_triangulation_3 now hides vertices (and updates itself) when
        inserting a coinciding point with greater weight.  This required a new
        predicate. </li>
      <LI> deprecated functions: copy_triangulation(), push_back(),
        set_number_of_vertices(). </li>
      <LI> Triangulation_3 now gives non-const access to the data structure. </li>
     </UL>
 </li>


<LI> Interval Skip List (new package)<BR>
An interval skip list is a data strucure for finding all intervals
      that contain a point, and for stabbing queries, that is for answering
      the question whether a given point is contained in an interval or not.
 </li>


<LI>
       Planar Maps and

       Arrangements<BR>

 The changes concern mainly the traits classes.
      <OL>
        <LI> New traits hierarchy and interface:
           The set of requirements was made sound and complete. A couple of
	   requirements were eliminated, few others were redefined, and some
	   were renamed. A hierarchy of three traits classes for the
	   Planar_map_2, Planar_map_with_intersections_2, and Arrangement_2
	   types was established to include only the necessary requirements at
           each level. It was determined that for the aggregate insertion-
	   operation based on a sweep-line algorithm only a subset of the
	   requirements is needed. Preconditions were added where appropriate
	   to tighten the requirements further.

           <p>
           The following functions have been renamed:
           <UL>
           <LI> point_is_same() renamed to point_equal() </li>
           <LI> curve_is_same() renamed to curve_equal() </li>
           <LI> curve_is_in_x_range() renamed to point_in_x_range() </li>
           <LI> curve_compare_at_x() renamed to curves_compare_y_at_x()
             Furthermore, a precondition has been added that the reference
	     point is in the x-range of both curves. </li>
           <LI> curve_compare_at_x_right() renamed to
	     curves_compare_y_at_x_to_right().
             Furthermore, a precondition has been added that both curves are
	     equal at the reference point and defined to its right. </li>
           <LI> curve_compare_at_x_left() renamed to
	     curves_compare_y_at_x_to_left().
             Furthermore, a precondition has been added that both curves are
	     equal at the reference point and defined to its right. </li>
           <LI> curve_get_point_status() renamed to curve_compare_y_at_x().
             Furthermore, a precondition has been added that the point is in
	     the x-range of the curve. Consequently, the function now returns a
	     Comparison_result (instead of a special enum). </li>
           <LI> make_x_monotone() renamed to curve_make_x_monotone()
             See more details below. </li>
           <LI> curve_flip() renamed to curve_opposite() </li>
           </UL>

           The following functions have been removed:
           <UL>
           <LI> curve_is_between_cw() </li>
           <LI> point_to_left() </li>
           <LI> point_to_right() </li>
           <LI> is_x_monotone() </li>
           <LI> point_reflect_in_x_and_y() </li>
           <LI> curve_reflect_in_x_and_y() </li>
           <LI> do_intersect_to_right() </li>
           <LI> do_intersect_to_left() </li>
           </ul>

           Most functions, are required by the PlanarMapTraits_2 concept,
	   except for the make_x_monotone(), nearest_intersection_to_right(),
           nearest_intersection_to_left(), curves_overlap() and
	   curve_opposite(). PlanarMapWithIntersectionsTraits_2 requires all
	   these functions, except curve_opposite(), needed only by the
	   ArrangementTraits_2 concept.
           <p>
           Furthermore, the two functions curve_compare_at_x_left() and
           nearest_intersection_to_left() can be omitted, if the two functions
	   point_reflect_in_x() and curve_reflect_in_x() are implemented.
	   Reflection can be avoided, if the two _left functions are supplied.
 </li>
 
        <LI> The type X_curve_2 of the PlanarMapWithIntersectionsTraits_2
           concept was renamed to X_monotone_curve_2, and the distinction
	   between this type and the Curve_2 type was made firm. The method
	   is_x_monotone() of the PlanarMapWithIntersectionsTraits_2 concept
	   was removed. The related method curve_make_x_monotone() is now
	   called for each input curve of type Curve_2 when curves are inserted
           into a Planar_map_with_intersections_2 to subdivide the input curve
	   into x-monotone sub-curves (and in case the curve is already
	   x-monotone, this function is responsible for casting it to an
	   x-monotone curve).
 </li>
        <LI> New and improved traits classes:
           <LI> Conic traits - Arr_conic_traits_2
             Support finite segments of ellipses, hyperbolas and parabolas, as
	     well as line segments. The traits require an exact real number-
	     type, such as leda_real or CORE::Expr. </li>

           <LI> Segment cached traits - Arr_segment_cached_traits_2
	     This class uses an improved representation for segments that helps
	     avoiding cascaded computations, thus achieving faster running
	     times. To work properly, an exact rational number-type should be
	     used. </li>

           <LI> Polyline traits - Arr_polyline_traits_2
             The polyline traits class has been reimplemented to work in a more
	     efficient, generic manner. The new class replaces the obsolete
	     Arr_polyline_traits class. It is parameterized with a segment
	     traits class. </li>

           <LI> Hyperbola and segment traits - Arr_hyper_segment_traits_2
             Supports line segments and segments of canonical hyperbolas.
	     This is the type of curves that arise when projecting segments
	     in three-space rotationally around a line onto a plane containing
	     the line. Such projections are often useful in CAD/CAM problems. </li>

        <LI> Removed old traits class:
           <UL>
            <LI> The models of the PlanarMapWithIntersectionsTraits_2 concept
	      below became obsolete, as the new conic traits, namely
	      Arr_conic_traits_2, supports the same functionality and is much
	      more efficient. </li>
              <UL>
                <LI> Arr_circles_real_traits </li>
                <LI> Arr_segment_circle_traits </li>
              </UL>
           <LI> The segment traits class and the new polyline traits class were
	      reimplemented using standard CGAL-kernel calls. This essentially
	      eliminated the corresponding leda traits classes, namely:
              <UL>
                <LI> Pm_leda_segment_traits_2 </li>
                <LI> Arr_leda_segment_traits_2 </li>
                <LI> Arr_leda_polyline_traits </li>
              </UL>
              With the use of the Leda_rat_kernel new external package the same
	      functionality can be achieved with less overhead and more
	      efficiency. </li>
      </UL> </li>
</li>
<LI> Sweep Line<BR>
      <UL>
       <LI> The Sweep_line_2 package was reimplemented. As a consequence it is much
        more efficient, its traits is tighter (namely neither the two _left nor
	the reflection functions are required), and its interface has changed a
	bit.
        <OL>
          <LI> The following global functions have been removed:
            <UL>
             <LI> sweep_to_produce_subcurves_2() </li>
             <LI> sweep_to_produce_points_2() </li>
             <LI> sweep_to_construct_planar_map_2() </li>
            </UL>
           Instead, the public methods of the Sweep_line_2 class listed below
	   were introduced:
           <UL>
             <LI> get_subcurves() - Given a container of curves, this function
	     returns a list of curves that are created by intersecting the
	     input curves. </li>

             <LI> get_intersection_points() - Given a range of curves, this function
	     returns a list of points that are the intersection points of the
	     curves. </li>

             <LI> get_intersecting_curves() - Given a range of curves, this function
	     returns an iterator to the beginning of a range that contains the
	     list of curves for each intersection point between any two curves
	     in the specified range. </li>
           </UL> </li>
        <LI> It is possible to construct a planar map with intersections (or an
	   arrangement) by inserting a range of curves into an empty map. This
	   will invoke the sweep-line process to construct the map more
	   efficiently. </li>
       </OL> </li>
      <LI> New interface functions to the Planar_map_with_intersections_2 class.
        The Planar_map_with_intersections_2 class maintains a planar map of
	input curves that possibly intersect each other and are not necessarily
	x-monotone. If an input curve, or a set of input curves, are known to
	be x-monotone and pairwise disjoint, the new functions below can be
	used to insert them into the map efficiently. </li>
       </UL>
  </OL> </li>


<LI> Polyhedral Surface<BR>
     <UL>
      <LI> The old design that was deprecated since CGAL 2.3 has been removed. </li>
      <LI> Class <tt>Polyhedron_incremental_builder_3</tt>:
	 <UL>
	  <LI>Renamed local enum <tt>ABSOLUTE</tt> to
              <tt>ABSOLUTE_INDEXING</tt>, and <tt>RELATIVE</tt> to
              <tt>RELATIVE_INDEXING</tt> to avoid conflicts with similarly
              named macros of another library. </li>
	  <LI>Changed member functions <tt>add_vertex()</tt>,
              <tt>begin_facet()</tt>, and <tt>end_facet()</tt> to return
              useful handles. </li>
          <LI>Added <tt>test_facet()</tt> to check facets for validity
              before adding them. </li>
          <LI>Added <tt>vertex( size_t i)</tt> to return <tt>Vertex_handle</tt>
              for index <tt>i</tt>. </li>
	 </ul> </li>
     </ul>
 </li>


<LI> Halfedge Data Structure<BR>
     <UL>
      <LI> The old design that was deprecated since CGAL 2.3 has been removed. </li>
     </UL>
 </li>
</UL>
</li>

<H3>Support Library</H3>

<ul>
    <li> New container class Compact_container, which (roughly) provides the
      flexibility of std::list, with the memory compactness of std::vector. </li>

    <li> Geomview_stream: added a function
      gv.draw_triangles(InputIterator begin, InputIterator end)
      which draws a set of triangles much more quickly than one by one. </li>

    <li> Number types:
      <ul>
      <li> number types are now required to provide a function:
        std::pair&lt;double, double&gt;  to_interval(const NT &amp;). </li>
      <li> number types are now required to provide mixed operators with "int". </li>
      <li> CLN support removed. </li>
      <li> faster square() for MP_Float. </li>
      <li> added Gmp_q. </li>
      </ul>
 </li>


    <li> Qt_widget:
      <ul>
       <li> New classes:
        <ul>
	<li> Qt_help_window: provides a simple way to show some helpful
	  information about a demo as an HTML page. </li>
	<li> Qt_widget_history: provides basic functionality to manipulate
	  intervals of Qt_widget class. The current visible area of Qt_widget
          is mapped to an interval. Each interval could be stored in the
	  Qt_widget_history object. So you can use this object to navigate in
          history.  It is mostly used by Qt_widget_standard_toolbar. </li>
         </ul> </li>
      <li> Changes:
        <ul>
	<li> Qt_widget_standard_toolbar: is derived from QToolBar class, so pay
	  attention to modify your code, if you used this class. Some public
	  methods were introduced to control the history object that the
          toolbar use to navigate. </li>
	<li> the icons are now part of libCGALQt. </li>
        </ul> </li>
      <li> Deprecated members of Qt_widget:
        <ul>
        <li> add_to_history(), clear_history(), back(), forth(): use forward(),
          back() and clear_history() of the Qt_widget_standard_toolbar instead. </li>
        <li> custom_redraw(): use redraw_on_back() and redraw_on_front() instead. </li>
         </ul> </li>
      <li> Optimizations:
        the output operators of the following classes have been optimized:
        <ul>
        <li> CGAL::Segment_2  (now tests for intersection with the drawing area) </li>
        <li> CGAL::Triangle_2 (now tests for intersection with the drawing area) </li>
        <li> CGAL::Triangulation_2 (is optimized for faster display on zooming) </li>
        </ul> </li>
      </ul> </li>
</ul>

<p id="kernelerratum-3.0"><H3>Erratum in the Kernel manual</H3>

<ul>
<li> Intersection test routines
    <p>The documentation of
    CGAL::do_intersect
    should mention, for the 3D case:
    <br>
    Also, in three-dimensional space <i>Type1</i> can be
    <ul>
        <li>either
        <i>Plane_3&lt;Kernel&gt;</i>
        <li>or <i>Triangle_3&lt;Kernel&gt;</i> </li>
    </ul>
    and <i>Type2</i> any of
    <ul>
        <li><i>Plane_3&lt;Kernel&gt;</i> </li>
        <li><i>Line_3&lt;Kernel&gt;</i> </li>
        <li><i>Ray_3&lt;Kernel&gt;</i> </li>
        <li><i>Segment_3&lt;Kernel&gt;</i> </li>
        <li><i>Triangle_3&lt;Kernel&gt;</i> </li>
    </ul>

    <p>
    In the same way, for
    <i>Kernel::DoIntersect_3</i>:
    <br>
    for all pairs <i>Type1</i> and <i>Type2</i>, where
    the type <i>Type1</i> is
    <ul>
        <li>either
        <i>Kernel::Plane_3</i> </li>
        <li>or <i>Kernel::Triangle_3</i> </li>
    </ul>

    and <i>Type2</i> can be any of the following:
    <ul>
        <li><i>Kernel::Plane_3</i> </li>
        <li><i>Kernel::Line_3</i> </li>
        <li><i>Kernel::Ray_3</i> </li>
        <li><i>Kernel::Segment_3</i> </li>
        <li><i>Kernel::Triangle_3</i> </li>
    </ul>

    <p>
    Philippe Guigue (I<small>NRIA</small> Sophia-Antipolis) should be
    mentioned as one of the authors.
 </li>
</ul>
