

<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>CGAL Projects for Google Summer of Code 2011</title>
    
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width">
    <meta name="author" content="CGAL Editorial Board">

    <link rel="icon" type="image/png" href="https://cgal.github.io/cgal-web/images/cgal_logo/g-196x196-y.png">
    <link rel="stylesheet" href="/cgal-web/node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="/cgal-web/node_modules/bootstrap-icons/font/bootstrap-icons.min.css">
    <link rel="stylesheet" href="/cgal-web/node_modules/bxslider/dist/jquery.bxslider.css">
    <link rel="stylesheet" href="/cgal-web/style.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700,600,800' rel='stylesheet' type='text/css'>

    <!--[if lte IE 8]>
	<link rel="stylesheet" href="css/leaflet.ie.css" />
	<![endif]-->
    <link rel="stylesheet" href="https://cgal.github.io/cgal-web/assets/themes/cgal/bootstrap/css/main.css">

    <!-- atom & rss feed -->
    <link href="https://cgal.github.io/cgal-web/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="https://cgal.github.io/cgal-web/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>
  <body>
    <!--[if lt IE 7]>
        <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->
    

    <!-- Navigation & Logo-->
    <div class="mainmenu-wrapper">
    <div class="container">
    <nav id="mainmenu" class="mainmenu" role="navigation">
    <ul>
    <li class="logo-wrapper hidden-xs hidden-sm hidden-md">
    <a href="https://cgal.github.io/cgal-web/index.html">
    <img src="https://cgal.github.io/cgal-web/images/cgal_front_page_2013.png" alt="CGAL Logo" width="250px">
    </a>
    </li>

    <li class="hidden-lg">
    <a href="https://cgal.github.io/cgal-web/index.html">
    <img src="https://cgal.github.io/cgal-web/images/cgal_front_page_2013.png" alt="CGAL Logo" height="20px">
    </a>
    </li>

    <li>
    <a href="https://cgal.github.io/cgal-web/project.html">Project</a>
    </li>

    <li>
    <a href="https://cgal.github.io/cgal-web/download.html">Download</a>
    </li>

    <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" data-hover="dropdown">Packages</a>
        <ul class="dropdown-menu">
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartAlgebraicFoundations" target="_blank">Arithmetic and Algebra</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartCombinatorialAlgorithms" target="_blank">Combinatorial Algorithms</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartKernels" target="_blank">Geometry Kernels</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartConvexHullAlgorithms" target="_blank">Convex Hull Algorithms</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartPolygons" target="_blank">Polygons</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartPolyhedra" target="_blank">Cell Complexes and Polyhedra</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartArrangements" target="_blank">Arrangements</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartTriangulationsAndDelaunayTriangulations" target="_blank">Triangulations</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartVoronoiDiagrams" target="_blank">Voronoi Diagrams</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartMeshing" target="_blank">Mesh Generation</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartReconstruction" target="_blank">Shape Reconstruction</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartGeometryProcessing" target="_blank">Geometry Processing</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartSearchStructures" target="_blank">Spatial Searching</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartGeometricOptimization" target="_blank">Geometric Optimization</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartInterpolation" target="_blank">Interpolation</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartSupportLibrary" target="_blank">Support Library</a></li>
          <li role="presentation"><a role="menuitem" tabindex="-1" href="https://doc.cgal.org/latest/Manual/packages.html#PartVisualization" target="_blank">Visualization</a></li>
        </ul>
    </li>

    <li>
    <a href="https://cgal.github.io/cgal-web/documentation.html">Documentation</a>
    </li>

    <li>
    <a href="https://cgal.github.io/cgal-web/news.html">News</a>
    </li>

    <li>
    <a href="https://cgal.github.io/cgal-web/media.html">Media</a>
    </li>

    <li>
    <a href="https://cgal.github.io/cgal-web/support.html">Support</a>
    </li>

    </ul>
        </nav>
      </div>
    </div>

    <div class="section section-breadcrumbs">
      <div class="container">
        <div class="row">
          <div class="col-md-12">
            <h1>CGAL Projects for Google Summer of Code 2011 </h1>
          </div>
        </div>
      </div>
    </div>
    
    

<div class="section">
  <div class="container">
    


<h2>Accepted Projects</h2>
<p>
  As in 2010, the CGAL Project was a mentoring organization of the <a href="https://code.google.com/soc/">Google Summer of Code</a> in 2011.
  Successful projects can be found <a href="https://www.google-melange.com/archive/gsoc/2011/orgs/cgal">here</a>.
</p>

<h2>Project Ideas</h2>
<p>
  On this page we presented some project ideas.
</p>

<p>Previous project ideas of the CGAL project for the <b>Google Summer of Code</b> can be found on the following pages: <a href="2010.html">2010</a>.

<h3>Summary:</h3>

<ol>
  <li> <a href="#multiProcessing">Enhancing Some Packages via Multi-Processing</a>
    <ol>
      <li> <a href="#mpArrBgl">Adapting Arrangement to the Parallel Boost
	  Graph Library</a>
      <li> <a href="#mpDivideAndConquer">Parallelizing Divide-And-Conquer</a>
    </ol>
  <li> <a href="#boostification">Replacing some basic non-geometric tools in CGAL by Boost/TR1/C++0x functionality</a>
  <li> <a href="#embeddedGraph">Switching from CGAL::HalfedgeGraph to boost::PlanarEmbedding</a>
  <li> <a href="#minkowskiSum">Supporting Minkowski Sum of Degenerate
      and Generalized Polygons</a>
  <li> <a href="#addEigen">Add an Interface for the Eigen Library</a>
  <li> <a href="#meshDeformation">Integrate As-Rigid-As-Possible Surface Modeling in CGAL</a>
  <li> <a href="#arrangement">Enhancing the <em>2D Arrangement</em> package</a>
    <ol>
      <li> <a href="#arrangementWithHistory">Enhancing the Arrangement-with-History component and Polygon Repairing</a>
      <li> <a href="#planeSweep">Enhancing the Plane-Sweep Framework for Arrangements</a>
      <li> <a href="#pointLocation">Enhancing the Point Location</a>
    </ol>
  <li> <a href="#triOperators">Local Operators in 3D Triangulations</a>

</ol>

<hr>

<h3 id="multiProcessing">Enhancing Some Packages via Multi-Processing</h3>

<p><strong>Mentor:</strong> <a href="mailto:ophir.setter@cs.tau.ac.il?Subject=GSoC-2011-MultiProcessing">Ophir Setter</a> from the <a href="http://acg.cs.tau.ac.il/people">Applied Computational Geometry Lab</a>, Tel Aviv University</p>
<p>Though the CGAL code is designed to be efficient, as
  multi-core processors become ubiquitous, the demand for
  multi-threaded data-structures rises. The idea of the project is
  to enable multi-threading in some of the CGAL packages. This
  enhancement is expected to contribute a significant performance
  boost in real-world multi-core scenarios. Some of the tasks should
  be tested and benchmarked on real-world data.</p>
<ol>
  <!--<li>Thread-safe Arrangement_2 and multi-threaded
      zone-insertion algorithm:

      <p>The zone algorithm is the perfect candidate to be
        multi-threaded. As different lines are inserted to different
        parts of the arrangement, there is no need to wait for the
        last insertion to finish. This will require a careful
        insertion of mutexes to the arrangement data-structure to
        enable fast zone-insertion of curve without corrupting the
        structure. The result performance improvement should be very
        significant.</p>-->

  <li id="mpArrBgl"><h3>Adapting Arrangement to the Parallel Boost
      Graph Library</h3>


    <h3>Project Description</h3>
    <p>The Arrangement data-structure is already adapted to the
      Boost Graph Library [<a href="#SLL02">SLL02</a>]
      (<a href="http://www.boost.org/doc/libs/release/libs/graph/">BGL</a>)
      which enables the user to run BGL algorithms on the
      arrangement data-structure. The task includes adapting the
      arrangement data-structure to the Parallel Boost Graph
      Library
      (<a href="http://osl.iu.edu/research/pbgl/">PBGL</a>) to
      enable users to run parallel graph algorithms on the
      Arrangement data-structure out-of-the-box. This requires
      implementing additional concepts imposed by PBGL.</p>

    <table class="BibliographyPage">
      <tr>
	<td align="left" valign="top" nowrap id="SLL02"><em>[SLL02]</em></td>
	<td>J. G. Siek, L.-Q. Lee, and A. Lumsdaine. <em>The Boost Graph Library</em>. Addison-Wesley, Boston, MA, USA, 2002.</td>
      </tr>
    </table>

  <li id="mpDivideAndConquer"><h3>Parallelizing Divide-And-Conquer</h3>
    <h3>Project Description</h3>
    <p>Some of the algorithms in the <em>2D Arrangement</em>
      package and related packages use a divide-and-conquer
      approach. This approach enables the immediate improvement by
      multi-threading. The following components are candidates for
      such an enhancement:</p>

    <ol>
      <li>Boolean set-operations --- The algorithms in the
        <em>2D Regularized Boolean Set-Operations</em>
        package can use both a D&amp;C approach and a sweep-line
        approach. This task also includes the investigation of
        the trade off between the two approaches.

      <li>Envelope algorithms.

      <li>Minkowski sum using convex decomposition.

    </ol>
</ol>
<p><strong>Required skills:</strong> C++ and Multithreading in C++.<br>

<hr>

  <h3 id="boostification">Replacing some Basic Non-Geometric Tools in CGAL by Boost/TR1/C++0x Functionality</h3>
<p><strong>Mentor:</strong> <a href="mailto:Sebastien.Loriot@geometryfactory.com?Subject=GSoC-2011-TR1">Sebastien Loriot</a> from <a href="http://www.geometryfactory.com/aboutus.html">GeometryFactory</a>
  <br>
  <h3>Project Description</h3>
<p>The CGAL project started in 1996, before the
  first C++ standard was released, and before the
  <a href="http://www.boost.org/">Boost</a>
  project was launched.  CGAL has accumulated a number of
  geometry-independent tools which these days offer duplicate
  functionality with what is (a) in TR1, (b) planned for the next C++
  standard C++0x, and/or (c) are in Boost.  Doing the replacement would help
  in the long-term by easing maintenance: (a) less code to maintain, and (b)
  new people are more likely to know about a standard tool, and it will be
  more useful to them to learn about them, rather than something
  which is only in CGAL and with no geometric or scientific flavor.</p>

<p>The goal of this project would be to "cleanup" CGAL by replacing as
  many of these as possible. Of course, depending on the case, there can
  be constraints in terms of efficiency, API compatibility, deprecation
  paths, etc.  So, the task is not trivial, but there are pieces easier
  than others.  It should be a nice way to learn about various standard
  tools in CGAL, Boost and C++0x.</p>

<p>Some examples of things to be considered:</p>
<pre>
  Filter_iterator        -&gt;  boost::filter_iterator
  Object                 -&gt;  boost::any/variant
  Triple/Quadruple       -&gt;  TR1::tuple/array
  Unique_hash_map        -&gt;  TR1::unordered_map/set
  copy_n                 -&gt;  C++0x::copy_n
  iterator ranges        -&gt;  Boost.Range
  Timers                 -&gt;  Boost.Timers
  Integer8/16/32         -&gt;  int32_t...
  min_max_element        -&gt;  C++0x (or TR1 ?)
  predecessor/successor  -&gt;  prev/next (C++0x/TR1)
</pre>
<p><strong>Required skills:</strong>boost, advanced C++.<br>

<hr>

<h3 id="embeddedGraph">Switching from CGAL::HalfedgeGraph to boost::PlanarEmbedding</h3>

<p><strong>Mentor:</strong> <a href="mailto:andreas.fabri@geometryfactory.com?Subject=GSoC-2011-PlanarEmbedding">Andreas Fabri</a> from  <a href="http://www.geometryfactory.com/aboutus.html">GeometryFactory</a>
  <br>
  <h3>Project Description</h3>
<p>Inspired by the Boost Graph Library (BGL), we extended the Graph concept by introducing the
  <a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/BGL/Chapter_main.html#Section_72.2">HalfedgeGraph</a>.
  This concept imposes an order on the edges incident to a vertex. It
  leads to the notion of edges cycles and hence faces. Currently, the CGAL
  <a href="http://www.cgal.org/Pkg/SurfaceMeshSimplification">Surface Mesh
    Simplification</a> package operates on polyhedral surfaces using this
  API.</p>

<p>Starting with boost Rel 1.35, the BGL added the notion of
  <a href="http://www.boost.org/doc/libs/1_46_0/libs/graph/doc/planar_graphs.html">PlanarEmbeddings</a>.</p>

<p>The goal of this project is to investigate how we can switch to this
  PlanarEmbedding concept, and if it still needs further extensions for
  our purposes. The next step is to make the necessary changes in the
  Surface Mesh Simplification package. If there still remains time, the
  student could start to rewrite the CGAL
  <a href="http://www.cgal.org/Pkg/:SurfaceParameterization">
    Surface Mesh Parametrisation</a>
  package, which took another approach to make an abstraction of a
  polyhedral surface.</p>

<p><strong>Required skills:</strong>BGL, advanced C++.<br>

<hr>

<h3 id="minkowskiSum">Supporting Minkowski Sum of Degenerate and Generalized Polygons</h3>
<p><strong>Mentors:</strong>
  <a href="mailto:efifogel@gmail.com?Subject=GSoC-2011-Minkowski">Efi Fogel</a> and <a href="mailto:mhsaar@googlemail.com?Subject=GSoC-2011-Minkowski">Michael Hemmer</a>
  from the <a href="http://acg.cs.tau.ac.il/people">Applied Computational Geometry Lab</a>,  Tel Aviv University</p>
<h3>Project Description</h3>
<p>Given two sets <var>A</var>, <var>B</var> &isin; R<sup>2</sup>,
  their <em>Minkowski sum</em>, denoted as
  <var>A</var> &oplus; <var>B</var>, is their point-wise sum,
  namely the set:</p>
<table>
  <tr>
    <td>&nbsp</td>
    <td> <var>A</var> &oplus; <var>B</var> = {<var>a</var> + <var>b</var> | <var>a</var> &isin; <var>A</var>, <var>b</var> &isin; <var>B</var>}.</td>
  </tr>
</table>

<p>Minkowski sums are used in many applications, such as
  motion planning and computer-aided design and manufacturing.</p>

<p>The <em>2D Minkowski Sums</em> package of CGAL contains
  the function
  <a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Minkowski_sum_2_ref/Function_minkowski_sum_2.html#Cross_link_anchor_1084"><code>minkowski_sum_2()</code></a> that computes the planar Minkowski sums of two
  simple polygons (see the
  <a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Boolean_set_operations_2/Chapter_main.html#Section_19.2">manual</a>
  for the precise definition of a simple polygon). The function
  is overloaded with two variants; one implements the
  <em>decomposition</em> method and the other implements
  the <em>convolution</em> method. Both summands are restricted
  to simple polygons that do not contain holes. (Resulting sums
  may contain holes though.)</p>

<p>The <em>2D Minkowski Sums</em> package, like the
  <em>2D Regularized Boolean Set-Operations</em> package, is
  implemented on top of the arrangement infrastructure. The two
  packages are integrated well to allow mixed operations.
  However, while the latter supports operations on polygons
  the boundaries of which comprise <var>x</var>-monotone
  curves that are not necessarily line segments, the former is
  restricted to linear polygons only.</p>

<p>You are asked to enhance the implementations of the package
  to support the following:</p>
<ol>
  <li>Minkowski sums of degenerate polygons, where any summand
    reduces to a line segment or to a point using both
    decomposition and convolution methods.</li>
  <li>Minkowski sums of generalized polygons the boundaries
    of which comprise circular arcs or line segments using the
    convolution method.</li>
  <li>Minkowski sum of polygons with holes using the
    decomposition method. This implies introducing a
    decompisition operation that decomposes polygons with
    holes.
</ol>

<p><strong>Required skills:</strong> C++, templates, Minkowski sum.<br>

<hr>

<h3 id="addEigen">Add an Interface for the Eigen Library</h3>

<p><strong>Mentors:</strong> <a href="mailto:sebastien.loriot@geometryfactory.com?Subject=GSoC-2011-Eigen">Sebastien Loriot</a> from  <a href="http://www.geometryfactory.com/aboutus.html">GeometryFactory</a>
  and <a href="mailto:gael.guennebaud@inria.fr?Subject=GSoC-2011-Eigen">Gael Guennebaud</a> from <a href="http://www.labri.fr/perso/guenneba/">LaBRI</a> Bordeaux.

  <h3>Project Description</h3>
<p>Several CGAL packages need to solve sparse linear systems. As CGAL has
  a clear focus on geometry, we use a third party library for this purpose:
  Taucs. The main drawback of Taucs is that it has no active developer
  community maintaining it and making it evolve.</p>

<p>The goal of this project is to interface CGAL with the
  <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>
  library.  This project is about interfacing software, hence beyond
  C++ programming one has to care about the build system, cross-platform
  aspects.  Depending on the progress of this project, an additional task would
  be to work on out-of-core functionality.

<p>This project will be co-mentored by Gael Guennebaud for the  Eigen library
  and by Sebastien Loriot for CGAL</p>

<p><strong>Required skills:</strong> C++, templates, cmake, solvers.<br>

<hr>

<h3 id="meshDeformation">Integrate As-Rigid-As-Possible Surface Modeling in CGAL</h3>

<p><strong>Mentors:</strong> <a href="mailto:andreas.fabri@geometryfactory.com?Subject=GSoC-2011-ARAP">Andreas Fabri</a> from  <a href="http://www.geometryfactory.com/aboutus.html">GeometryFactory</a>,
  and <a href="mailto:sorkine@inf.ethz.ch?Subject=GSoC-2011-ARAP">Olga Sorkine</a> from <a href="http://people.inf.ethz.ch/sorkineo">ETH Zurich</a>.

  <h3>Project Description</h3>
<p>In their SGP 2007 paper entitled <a href="http://people.inf.ethz.ch/sorkineo/ProjectPages/ARAP_modeling/arap_web.pdf"><em>As-Rigid-As-Possible Surface Modeling</em></a> Olga Sorkine and Marc Alexa present a new algorithm for deforming a polyhedral surface, when a zone and some handles on the surface are selected and the user moves the handles in space. A video captured with a prototype implementation can be watched  <a href="http://people.inf.ethz.ch/sorkineo/ProjectPages/ARAP_modeling/arap_video640.mov">here</a> or on <a href="http://www.youtube.com/watch?v=ltX-qUjbkdc">YouTube</a>. </p>

<p>As evaluators of the prototype implementation were satisfied,
  we plan to reimplement the algorithm in CGAL, so that it operates
  on CGAL polyhedral surfaces, and uses the solver APIs of CGAL
  that allow to easily exchange the underlying solver.</p>

<p>This project will be co-mentored by Olga Sorkine as far as the algorithm
  itself is concerned and by Andreas Fabri as far as CGAL and software design questions
  are concerned.</p>

<p><strong>Required skills: </strong>geometry processing, numerical solvers, C++, templates.<br>

<hr>

<h3 id="arrangement">Enhancing the <em>2D Arrangement</em> Package</h3>
<p><strong>Mentors:</strong> <a href="mailto:efifogel@gmail.com?Subject=GSoC-2011-Arrangement"> Efi Fogel</a> and  <a href="mailto:mhsaar@googlemail.com?Subject=GSoC-2011-Arrangement">Michael Hemmer</a> from
  the <a href="http://acg.cs.tau.ac.il/people">Applied Computational Geometry Lab</a>, Tel Aviv University</p>
<p>The <em>2D Arrangement</em> package of CGAL has a long
  history. Like many other packages, it is the result of a long
  development process. Over the years this package has evolved. The
  code went through small and large modifications in form of bug
  fixes, extensions, restructuring, and re-design. Through the
  years we have also collected a modest number of features that we
  haven't implemented yet. Three of these missing features are
  listed below. Each item is considered as a separate project. You
  many need to refer to the user manual to understand what the
  project is about.
  <ol>
    <li id="arrangementWithHistory"><h3>Enhancing the Arrangement-with-History component and Polygon Repairing</h3>
      <h3>Project Description</h3>
      <p>Boolean operations on polygons, referred to as Boolean
        set-operations, constitute fundamental tasks in
        computational geometry. These operations are ubiquitous in
        computer graphics, computer aided design and manufacturing
        (CAD/CAM), electronic-design automation, and many more
        domains. Unfortunately, input data of such operations,
        namely a set of one or more polygons, used in real-world
        applications is occasionally corrupted, as it originates
        from measuring devices that are susceptive to noise and
        physical disturbances. In some other cases, it contains
        many degeneracies, which either disable computations based
        on fixed-precision arithmetic, or slow down further
        computation using multi-precision geometric
        computation. CGAL offers the package <em>2D Regularized
          Boolean Set-Operation</em>, which supports Boolean
        set-operations on point sets bounded by
        <var>x</var>-monotone segments in two-dimensional
        Euclidean space. These operations expect each input
        point-set to meet a specific set of requirements.
        Naturally, passing point sets that fail to meet these
        requirements as input to a Boolean set-operation must be
        avoided.</p>

      <p><img align="right" src="https://cgal.github.io/cgal-web/images/gsoc/bad_polygon.gif" alt="bad_polygon" />
        A simple point-set is topologically equivalent to a disc,
        and has a well-defined interior and exterior.
        Automatically "fixing" corrupted data, that is, converting
        invalid point-sets, the interiors and exteriors of which
        are not well defined to valid ones, is not a simple
        task. As a matter of fact, it is impossible to come up
        with a procedure that yields the desired results in all
        cases. Consider, for example, the self-intersecting
        polygon depicted on the right. It is uncertain which
        points are contained in the point set and which ones are
        not, but including the green small triangle on the right
        and excluding the red small triangle on the left is a good
        guess. Winding numbers appear to be useful in such cases. The
        <a href="http://en.wikipedia.org/wiki/Winding_number">winding number</a>
        of a point is the number of counterclockwise cycles the
        oriented boundary makes around the point. It is common to
        use one of the following three heuristics (although one
        could come up with more options):</p>
      <ul>
        <li> Consider a point included in the point set only if
          its winding number is non-zero.
        <li> Consider a point included in the point set only if its
          winding number is greater than zero.
        <li> Consider a point included in the point set only if its
          winding number is odd.
      </ul>

      <p>Computing the winding number of a point set bounded by
        linear segments can conveniently be done with arrangements
        supported by the <em>2D Arrangement</em> package, and in
        particular with the arrangement-with-history
        class-template. The <em>2D Regularized Boolean
          Set-Operation</em> package supports polygons the
        boundaries of which comprise <var>x</var>-monotone curves
        that are not necessarily line segments. Such polygons are
        referred to as "General Polygons". Computing the
        winding numbers of general polygons requires an extension
        of the arrangement-with-history class-template.</p>

      <p>When you construct an arrangement induced by a
        set <var>C</var> of arbitrary planar curves, you end up
        with a collection <var>C''</var> of <var>x</var>-monotone
        subcurves of <var>C</var> that are pairwise disjoint in
        their interior. These subcurves are associated with the
        arrangement edges (more precisely, with pairs of
        <a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2_ref/Concept_ArrangementDcel.html#Cross_link_anchor_1157">DCEL</a>
        halfedges). The connection between the original input
        curves and the arrangement edges is lost during the
        construction process. This loss might be acceptable for
        some applications. However, in many practical cases it is
        important to determine the input curves that give rise to
        the final subcurves.</p>

      <p>The
        <a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2_ref/Class_Arrangement_with_history_2.html#Cross_link_anchor_1239"><code>Arrangement_with_history_2&lt;Traits,Dcel&gt;</code></a>
        class-template extends the
        <a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2_ref/Class_Arrangement_2.html#Cross_link_anchor_1137"><code>Arrangement_2&lt;Traits,Dcel&gt;</code></a>
        class template with an additional container that
        represents <var>C</var> and a cross mapping between the curves of
        <var>C</var> and the arrangement edges they induce.</p>

      <p>The arrangement-with-history class-template is somehow deficient.
        For example, it is restricted to general curves that do
        not result with points when subdivided
        into <var>x</var>-monotone curves, as the interface allows
        a user to obtain induced edges only. Another deficiency,
        much more significant, is the lack on an intermediate layer,
        which represents the <var>x</var>-monotone curves.
        Let <var>C'</var> denote the set of maximal
        <var>x</var>-monotone subcurves of the curves
        in <var>C</var>. Recall that <var>C''</var> is the set of
        pairwise disjoint in their interiors subcurves of the curves
        in <var>C'</var>. You are asked to augment the
        <a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2_ref/Class_Arrangement_with_history_2.html#Cross_link_anchor_1239"><code>Arrangement_with_history_2</code></a>
        class-template with an additional container that
        represents <var>C'</var>, and (i) a cross mapping between
        the curves of <var>C</var> and the curves
        of <var>C'</var>, and (ii) a cross mapping between the
        curves of <var>C'</var> and the arrangement halfedges they
        induce.</p>

      <p>As a response to a user request for the curves (and
        isolated points) induced by a general curve, the range of
        either edges (and vertices) are returned in arbitrary
        order. However, as a response to a user request for the
        edges induced by an <var>x</var>-monotone curve, the range
        of edges are returned in order from left to right.</p>

      <p>The last part of this project is to develop a generic
        function that repairs corrupted general polygons
        exploiting the augmented arrangement-with-history
        class-template.</p>

      <p><strong>Required skills:</strong> C++, templates, Arrangement.<br>

        <li id="planeSweep"><h3>Enhancing the Plane-Sweep Framework for Arrangements</h3>
          <h3>Project Description</h3>
          <p><img align="right" src="https://cgal.github.io/cgal-web/images/gsoc/plane_sweep.gif" alt="plane_sweep" />
            The plane-sweep algorithm is a fundamental concept in
            Computational Geometry. It plays a central role in the
            algorithmic study of arrangements. The famous plane-sweep
            algorithm introduced by Bentley and Ottmann
            [<a href="#Ben75">Ben75</a>]
            was originally formulated for sets of line segments in the plane.
            Let <var>S</var> be a set of input line segments in the
            plane. Consider the vertical line <var>l</var> in the
            figure to the right. The intersections of the segments
            in <var>S</var> with <var>l</var> define a one-dimensional
            arrangement <var>A</var>(<var>S</var> &cap; <var>l</var>) on the line <var>l</var>. It comprises three vertices, and
            four one-dimensional cells, that is, two half-infinite
            intervals (rays), and two line segments. We can describe
            the combinatorial structure of the
            arrangement <var>A</var>(<var>S</var> &cap; <var>l</var>)
            by listing the curves that intersect <var>l</var> from
            bottom to top:
            &lt;<var>s</var><sub>2</sub>,<var>s</var><sub>3</sub>,<var>s</var><sub>1</sub>&gt;.
            If we specify the equation <var>x</var> = <var>x</var><sub>0</sub> of the line
            <var>l</var>, then we also get the coordinates of the
            vertices of the one-dimensional arrangement.</p>

          <p>If <var>l</var> does not cross a vertex of the
            two-dimensional arrangement <var>A</var>(<var>S</var>),
            and it is slightly (infinitesimally) moved to the right or
            to the left, the combinatorial structure of the
            one-dimensional arrangement on <var>l</var> remains
            intact. This structure changes only when <var>l</var> hits
            a vertex of the arrangement, either an endpoint of a line
            segment in <var>S</var> or the intersection point of two
            (or more) segments in <var>S</var>. Accordingly, we sweep
            the vertical line <var>l</var> over the collection of
            curves in the plane from <var>x</var> = -&infin;
            to <var>x</var> = +&infin; to discover vertices which are
            intersection points of curves, and other properties of the
            arrangement. We stop the sweep at a finite number of
            points, which we call <em>events</em>. The stopping points
            are endpoints and intersection points of the segments,
            since between any consecutive pair of events, the
            combinatorial structure of the one-dimensional arrangement
            on <var>l</var> does not change.

            We maintain two data structures to carry out the sweep
            efficiently. One structure describes the (dynamically
            changing) one-dimensional arrangement along the
            line <var>l</var>; it is called the <em>status
              structure</em>. The second structure is a queue that keeps
            track of the events, sorted in
            increasing <var>xy</var>-lexicographic order; it is called
            the <em>event queue</em>. Events that are known in advance
            are inserted into the queue at the beginning of the
            algorithm. This is the case with events associated with
            the endpoints of the curves. Other events, namely,
            intersection points between curves, are discovered as the
            algorithm proceeds. They are inserted into the queue when
            discovered.</p>

          <p>Sweeping <var>n</var> curves having <var>k</var>
            intersections, takes
            <var>O</var>((<var>n</var>+<var>k</var>)log <var>n</var>)
            time.
            In the literature you can find, in addition to a more detailed
            description of the algorithm, variants that handle degenerate cases
            and nuances about the time and space complexity of the algorithm.
            Notice that although the description above applies to line segments,
            the same procedure works seamlessly for any family
            of <var>x</var>-monotone curves.</p>

          <p>The <em>2D Arrangement</em> package offers a generic
            implementation of the plane-sweep algorithm in form of a
            class template called <code>Sweep_line_2&lt;Traits, Visitor&gt;</code>. It
            handles any set of arbitrary <var>x</var>-monotone curves,
            and serves as the foundation of a family of concrete
            operations, such as computing all points of intersections
            of a set of curves, (Strictly speaking this operation is
            provided by the <em>2D Intersection of Curves</em>
            package, which is based on the <em>2D Arrangements</em>
            package.) constructing an arrangement induced by a set of
            curves, aggregately inserting a set of curves into an
            existing arrangement, and computing the overlay of two
            arrangements. A concrete algorithm is realized through a
            plane-sweep visitor, the template parameter of
            the <code>Sweep_line_2</code> class-template, which
            resembles the <em>visitor</em> design-pattern
            [<a href="#GHJ+95">GHJ+95</a>, Chapter 5]. In our case a
            visitor defines an operation based on the plane-sweep
            algorithm to be performed on a set of curves and points.
            (The BOOST Graph-Library, for example, uses visitors
            [<a href="#SLL02bis">SLL02</a>, Chapter 12.3] to support
            user-defined extensions to its fundamental
            graph-algorithms.)</p>

          <p>Currently, the plane-sweep implementation does not
            support certain sets of <var>x</var>-monotone curves: The
            execution may fail if the input set contains a pair of
            <var>x</var>-monotone curves that overlap in a
            non-continuous portion. This may occur, for example, with
            polylines (continuous piecewise linear curves). The first
            part of this project is to enhance the implementation to
            support all types of <var>x</var>-monotone curves.<p>

          <p>The second part of the project is to implement the
            operations listed below through the introduction of
            suitable visitors.</p>
          <ol>
            <li>Computing all points of intersections of a set of
              <var>x</var>-monotone curves and maintain the
              association between each intersection point and the two
              (or more) <var>x</var>-monotone curves that induce the
              intersection.</li>
            <li>Finding the minimum-area triangle defined by a set
              of points in the plane. You may wonder what is the
              connection between this problem and the plane-sweep
              algorithm. To keep this text to minimum at this point,
              let us just say that one efficient algorithm to solve
              the problem requires the construction of the
              arrangement induced by the lines dual to the input
              points.</li>
          </ol>

          <p>The last part of the project is to expose the plane-sweep
            class-template to the public, so that other users can
            implement their own concrete algorithms. This requires
            implementing tests, developing additional examples, and
            writing the appropriate documentation.</p>
          <p>
	    <table class="BibliographyPage">
	      <tr>
	        <td align="left" valign="top" nowrap id="Ben75"><em>[Ben75]</em></td>
	        <td>J. L. Bentley. Multidimensional binary search trees
		  used for associative searching. <em>Communications of
		    the ACM</em>, 18(9):509-517, September 1975.</td>
	      </tr>
	      <tr>
	        <td align="left" valign="top" nowrap id="GHJ95"><em>[GHJ+95]</em></td>
	        <td>E. Gamma, R. Helm, R. Johnson, and
		  J. M. Vlissides. <em>Design Patterns --- Elements of
		    Reusable Object-Oriented
		    Software</em>. Addison-Wesley, Boston, MA, USA,
		  1995.</td>
	      </tr>
	      <tr>
	        <td align="left" valign="top" nowrap id="SLL02bis"><em>[SLL02]</em></td>
	        <td>J. G. Siek, L.-Q. Lee, and A. Lumsdaine. <em>The
		    Boost Graph Library</em>. Addison-Wesley, Boston, MA, USA, 2002.</td>
	      </tr>
	    </table>

          <p><strong>Required skills:</strong> C++, templates, Sweep-line framework.<br>

            <li id="pointLocation"><h3>Enhancing the Point Location</h3>
              <h3>Project Description</h3>
              <p> One of the most important query types defined on
                arrangements is the point-location query: Given a point,
                find the arrangement cell that contains it.
                Typically, the result of a point-location query is one
                of the arrangement faces, but in degenerate situations
                the query point can be located on an edge or coincide
                with a vertex. Point-location queries are not only common
                in many applications, they also play an important role in
                the global insertion-functions. Therefore, it is crucial
                to have the ability to answer such queries effectively
                for any arrangement instance. </p>

              <p><img align="right" src="https://cgal.github.io/cgal-web/images/gsoc/landmark_pl.gif" alt="landmark point-location" />The arrangement package includes several classes (more precisely,
                class templates parameterised by an arrangement class) that model
                the <a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2_ref/Concept_ArrangementPointLocation_2.html"> ArrangementPointLocation_2 </a>
                concept. Namely, they all have a member function called
                <code>locate()</code> that accepts a query point <em>q</em> and
                returns the face, edge or vertex that contains the query. Each of
                the various point-location classes employs a different algorithm
                or strategy for answering queries. One of the most important is the
                class using
                <a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2_ref/Class_Arr_landmarks_point_location.html">Landmarks</a>.
                The class uses a set of "landmark" points whose location in the
                arrangement is known. Given a query point, it uses a Kd-tree to find
                the nearest landmark and then traverses the straight line segment
                connecting this landmark to the query point.</p>

              <p>It is recommended to use the landmarks point-location strategy when
                the application frequently issues point-location queries on a rather
                static arrangement that the changes applied to it are mainly
                insertions of curves and not deletions of them. However, the current
                implementation is restricted to bounded arrangements and easy curve
                types. Fixing the first part is a rather straight forward task since
                it just means to adjust the existing code to the few special cases
                caused by unbounded curves. This will probably be a good warm up phase
                to get more familiar with the code. The second part is slightly more
                involved, since it is caused by the fact that (depending on the curve
                type) it is sometimes not easy to provide a "straight line segment"
                (or x-monotone curve) that connects a landmark point with a query
                point. Therefore, we would like to implement a different walk strategy
                that does not require the construction of a connecting segment. This
                would allow to relax the concept
                <a href=" http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2_ref/Concept_ArrangementLandmarkTraits_2.html">ArrangementLandmarkTraits_2</a>
                and would enable point location based on landmarks for a broader set
                of curve types such as B&eacute;zier curves, rational arcs, and algebraic
                segments.</p>
              <p><strong>Required skills:</strong> C++, templates, Arrangement and point location.<br>
  </ol>

<hr>

<h3 id="triOperators">Local Operators on 3D Triangulations</h3>

<p><strong>Mentor:</strong> <a href="mailto:pierre.alliez@sophia.inria.fr?Subject=GSoC-2011-Operators">Pierre Alliez</a> from  <a href="http://www-sop.inria.fr/members/Pierre.Alliez/">INRIA</a> Sophia Antipolis
  <br>
  <h3>Project Description</h3>
<p> CGAL provides already a rich set of triangulations in 2D and
  3D. In 2D these triangulations come with local operators such as
  edge flip or edge collapses which are useful a range of
  algorithms. In 3D the triangulations already provide a rich
  interface for inserting points, removing vertices, locating,
  etc. but lack some operators such as edge collapse or edge
  removal.</p>

<p>The goal of this project is to enhance the implementations
  of the 3D triangulations by adding the following features:</p>
<ol>
  <li> Edge collapse operator in the triangulation data structure (TDS).
    This requires adding two tests: one to preserve topology (so-called
    link condition) to be added to the TDS, and one to preserve
    geometric embedding (a polyhedron kernel test) to be added to
    the triangulation interface.
  <li> Edge removal operator in the triangulation data structure (TDS),
    useful among others to perform 3-2 and 4-4
    flips (see
    <a href="http://graphics.cs.berkeley.edu/papers/Klingner-ATM-2007-10/">paper</a>).
    This again requires devising topological and geometrical tests.
  <li> Assess all other operators described in
    <a href="http://graphics.cs.berkeley.edu/papers/Klingner-ATM-2007-10/">paper</a>
    and implement them.
</ol>

<p><strong>Required skills:</strong>computational geometry, C++.<br>

<br>
<h2 id="information">Information Candidates Should Supply</h2>

<p>The application process has several steps. Before contacting anybody verify that you are eligible, that is
  that you are enrolled as student, don't get a tuition fee, etc. The next step is to contact the mentor
  of the project you are interested in. You have to convince him that you are the right person to get the job
  done. The next step is to work out more details and to contact the mentoring organization by providing
  the following information by email to <a href="mailto:gsoc-cgal@lists-sop.inria.fr">gsoc-cgal@lists-sop.inria.fr</a></p>


<h3>Project</h3>
<ol>
  <li> Select a project in the list and provide your personal and detailed description. If you wish to work on another idea of your own, we are pretty open as long as this serves the goal of consolidating CGAL as a whole.
  <li> Provide a proposal of a technical solution with your envisioned methodology. The more detailed the better.
  <li> Explain how the solution will be available to the user, in which form. Do not forget the documentation, unitary tests and cross-platform aspects.
  <li> Provide a realistic schedule with objectives (one every two weeks for example) and deadlines. Focus on mid-term objectives as well as on the final evaluation.
  <li> Provide a formal commitment that you will be involved full time on the GSoC. This is absolutely mandatory.
</ol>

<h3>Personal data</h3>
<ol>
  <li> First name, last name, affiliation and geographical location.
  <li> A brief list of the main studies and programming courses attended, with ranking.
  <li> List of the most important software projects contributed and success.
  <li> Which are your best skills in terms of programming and scientific computing?
  <li> In general what is your taste in terms of programming? language, methodology, team work, etc.
  <li> Is there anything that prevents you from working full time on the project during the program period?
  <li> How do you see your involvement after the program ends? Do you see yourself pushing the project further, or do you see yourself contributing to other CGAL projects?
  <li> Are you more interested in the theory/scientific aspect of CGAL, or do you feel more like a hacker?
  <li> What are your long-term wishes in terms of job?
</ol>

<h3>A mailto:</h3>

<p>This
  <a href="mailto:gsoc-cgal@lists-sop.inria.fr?subject=GSOC-2011&amp;body=%0AProject%0A%0A
           * Select a project in the list and provide your personal and detailed description. %0A
           * Provide a proposal of a technical solution with your envisioned methodology. The more detailed the better.%0A
           * Explain how the solution will be available to the user, in which form. Do not forget the documentation, unitary tests and cross-platform aspects.%0A
           * Provide a realistic schedule with objectives (one every two weeks for example) and deadlines. Focus on mid-term objectives as well as on the final evaluation.%0A
           * Provide a formal commitment that you will be involved full time on the GSoC. This is absolutely mandatory.%0A%0A

           Personal data%0A%0A
           * First name, last name, affiliation and geographical location.%0A
           * A brief list of the main studies and programming courses attended, with ranking.%0A
           * List of the most important software projects contributed and success.%0A
           * Which are your best skills in terms of programming and scientific computing?%0A
           * In general what is your taste in terms of programming? language, methodology, team work, etc.%0A
           * Is there anything that prevents you from working full time on the project during the program period?%0A
           * How do you see your involvement after the program ends? Do you see yourself pushing the project further, or do you see yourself contributing to other CGAL projects?%0A
           * Are you more interested in the theory/scientific aspect of CGAL, or do you feel more like a hacker?%0A
           * What are your long-term wishes in terms of job?%0A">anchor</a> is a mailto: with a mail body containg the above items.

  </div>
</div>


    
    <!-- Footer -->
    <div class="footer">
      <div class="container">
        <div class="col-md-12">
          <div class="footer-copyright">
            <div style="float: left;">
              <a href="https://twitter.com/TheCGALProject" alt="The CGAL Project's Twitter">
                <img src="https://cgal.github.io/cgal-web/images/icons/twitter.svg" class="center-block btn-dark-orange" alt="Twitter" height="18"></img>
              </a>
            </div>
            &copy; 1995-2023 The CGAL Project. All rights reserved.
            <div style="float: right;">
              <a href="https://cgal.geometryfactory.com/CGAL/Members/wiki/Main_Page" alt="Password protected access to the Developer Wiki">
                <i class="bi bi-lock-fill fs-5"></i>
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Javascripts -->
    <script src="/cgal-web/node_modules/jquery/dist/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="/cgal-web/node_modules/jquery/dist/jquery.min.js"><\/script>')</script>
      <script src="/cgal-web/node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
      <script src="/cgal-web/node_modules/bxslider/dist/jquery.bxslider.min.js"></script>
      <script>
        $(function () {
          $('.bxslider').bxSlider({
            auto: true,
            speed: 0,
            pause: 5000,
            infiniteLoop: true,
            touchEnabled: false,
            pager: true,
            pagerCustom: '.custom-pager',
            controls: false,
            onSliderLoad: function (currentIndex) {
              $('.bxslider li').find('.slideTitle, .slideSubTitle').css({
                transform: 'translate(0)',
                opacity: 1
              });
              $('.bxslider li').eq(currentIndex).find('.slideTitle, .slideSubTitle').addClass('animatedTitle');
            },
            onSlideBefore: function ($slideElement, oldIndex, newIndex) {
              $($slideElement).siblings().find('.slideTitle, .slideSubTitle').removeClass('animatedTitle');
              $($slideElement).find('.slideTitle, .slideSubTitle').addClass('animatedTitle');
              $($slideElement).siblings().find('.slide').removeClass('slideInFromRight');
              $($slideElement).find('.slide').addClass('slideInFromRight');
            }
          });
        });
      </script>
      <script src="/cgal-web/node_modules/bootstrap-hover-dropdown/bootstrap-hover-dropdown.min.js"></script>
    </body>
</html>

